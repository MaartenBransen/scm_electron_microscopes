<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>scm_electron_microscopes.sem API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scm_electron_microscopes.sem</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import cv2
import numpy as np
from .utility import util

class helios:
    &#34;&#34;&#34;
    Set of convenience functions for the Helios SEM.
    &#34;&#34;&#34;
    def __init__(self,filename):
        &#34;&#34;&#34;
        initialize class by loading the file

        Parameters
        ----------
        filename : string
            name of the file to load. Can but is not required to include .tif
            as extension.


        Returns
        -------
        None.

        &#34;&#34;&#34;
        
        #raise error if wrong format or file does not exist
        if type(filename) != str:
            raise TypeError(&#39;The argument to the helios class must be a string containing the filename.&#39;)
        if not os.path.exists(filename):
            if os.path.exists(filename + &#39;.tif&#39;):
                filename = filename + &#39;.tif&#39;
            else:
                raise FileNotFoundError(&#39;The file &#34;&#39;+filename+&#39;&#34; could not be found.&#39;)
            
        self.filename = filename
    
    def load_image(self):
        &#34;&#34;&#34;
        load the image and split into image and databar

        Returns
        -------
        numpy.array
            array of pixel values in the image (not including the data bar)

        &#34;&#34;&#34;
        im = cv2.imread(self.filename,0)
        self.shape = np.shape(im)
        self.image = im[:int(self.shape[1]/1.5)]
        if int(self.shape[1]/1.5) &lt; self.shape[0]:
            self.databar = im[int(self.shape[1]/1.5):]
        else:
            self.databar = None
        return self.image
    
    def load_metadata(self):
        &#34;&#34;&#34;
        Load the metadata footer from Helios SEM files and return xml tree
        object which can be indexed for extraction of useful parameters. Does
        not require loading whole file into memory. Attempts first to find xml
        formatted data, if this is not found it looks for &#39;human&#39; formatted
        metadata.

        Returns
        -------
        xml.etree.ElementTree root object
            xml root object of the metadata. Can be printed using it as
            argument to print_metadata, or indexed with
            xml_root.find(&#39;&lt;element name&gt;&#39;).

        &#34;&#34;&#34;
        import io
        import xml.etree.ElementTree as et
        
        metadata = &#39;&#39;
        read = False
        
        #for slice and view images the metadata is already in xml format
        try:
            with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
                #read file line by line to avoid loading too much into memory
                for line in file:
                    #start reading at the first line containing an xml tag
                    if &#39;&lt;?xml&#39; in line:
                        read = True
                    if read:
                        metadata += line
                        if &#39;&lt;/Metadata&gt;&#39; in line:
                            break #stop at line with end tag
            
            #trim strings down to only xml
            metadata = metadata[metadata.find(&#39;&lt;?xml&#39;):]
            metadata = metadata[:metadata.find(&#39;&lt;/Metadata&gt;&#39;)+11]
            
            self.metadata = et.fromstring(metadata)
            return self.metadata
        
        #otherwise construct the metadata from formatted metadata in file
        except:
            with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
                for line in file:
                    #start reading at first line with [User], break at next \x00
                    if read:
                        metadata += line
                        if &#39;\x00&#39; in line:
                            break
                    if &#39;[User]&#39; in line:
                        read = True
                        metadata += line
            
            metadata = metadata[metadata.find(&#39;[User]&#39;):]
            metadata = metadata[:metadata.find(&#39;\x00&#39;)-2]
            metadata = metadata.split(&#39;\n&#39;)
            
            #construct xml object
            xml_root = et.Element(&#39;MetaData&#39;)
            for line in metadata:
                if line != &#39;&#39;:
                    if line[0] == &#39;[&#39;:
                        child = et.SubElement(xml_root,line[1:-1])
                    else:
                        line = line.split(&#39;=&#39;)
                        subchild = et.SubElement(child,line[0])
                        subchild.text = line[1]
            
            self.metadata = xml_root
            return xml_root
    
    def print_metadata(self):
        &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
        
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        util.print_metadata(xml_root)
        
        
    def get_pixelsize(self):
        &#34;&#34;&#34;
        gets the pixel size from the metadata and calculates the unit

        Returns
        -------
        pixelsize : float
            the pixelsize in calibrated (physical) units
        unit : string
            the physical unit of the pixel size

        &#34;&#34;&#34;
        #get the metadata or load it if it is not (yet) available
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        #find the pixelsize (may be two different formats)
        try:
            pixelsize_x = float(xml_root.find(&#39;Scan&#39;).find(&#39;PixelWidth&#39;).text)
            pixelsize_y = float(xml_root.find(&#39;Scan&#39;).find(&#39;PixelHeight&#39;).text)
        except:
            pixelsize_x = float(xml_root.find(&#39;BinaryResult&#39;).find(&#39;PixelSize&#39;).find(&#39;X&#39;).text)
            pixelsize_y = float(xml_root.find(&#39;BinaryResult&#39;).find(&#39;PixelSize&#39;).find(&#39;Y&#39;).text)
        
        #find the right unit and rescale for convenience
        if pixelsize_x &gt;= 0.1:
            unit = &#39;m&#39;
        elif pixelsize_x &lt; 0.1 and pixelsize_x &gt;= 0.1e-3:
            unit = &#39;mm&#39;
            pixelsize_x,pixelsize_y = 1e3*pixelsize_x,1e3*pixelsize_y
        elif pixelsize_x &lt; 0.1e-3 and pixelsize_x &gt;= 0.1e-6:
            unit = &#39;µm&#39;
            pixelsize_x,pixelsize_y = 1e6*pixelsize_x,1e6*pixelsize_y
        else:
            unit = &#39;nm&#39;
            pixelsize_x,pixelsize_y = 1e9*pixelsize_x,1e9*pixelsize_y
        
        pixelsize = (pixelsize_x,pixelsize_y)
        print(&#39;Pixel size x: {:.6g}&#39;.format(pixelsize[0]),unit)
        print(&#39;Pixel size y: {:.6g}&#39;.format(pixelsize[1]),unit)
        
        self.pixelsize= pixelsize
        self.unit = unit
        
        return pixelsize,unit


#==============================================================================
# PHENOM
#==============================================================================
class phenom:
    &#34;&#34;&#34;
    Set of convenience functions for the phenom SEM microscopes.
    &#34;&#34;&#34;
    def __init__(self,filename):
        &#34;&#34;&#34;Initialize the class instance&#34;&#34;&#34;
        
        #raise error if wrong format or file does not exist
        if type(filename) != str:
            raise TypeError(&#39;The argument to the helios class must be a string containing the filename.&#39;)
        if not os.path.exists(filename):
            raise FileNotFoundError(&#39;The file &#34;&#39;+filename+&#39;&#34; could not be found.&#39;)
            
        self.filename = filename
    
    def load_image(self):
        &#34;&#34;&#34;load the image and split into image and databar&#34;&#34;&#34;
        im = cv2.imread(self.filename,0)
        self.shape = np.shape(im)
        self.image = im[:int(self.shape[1])]
        self.databar = im[int(self.shape[1]):]
        return self.image
    
    def load_metadata(self):
        &#34;&#34;&#34;
        Load the metadata footer from Helios SEM files and return xml tree
        object which can be indexed for extraction of useful parameters. Does
        not require loading whole file into memory. Attempts first to find xml
        formatted data, if this is not found it looks for &#39;human&#39; formatted
        metadata.
        
        @dependencies:
            import io
            import xml.etree.ElementTree as et
        
        @parameters:
            self.filename:   string
        
        @returns:
            xml root object of the metadata. Can be printed using it as
            argument to print_metadata, or indexed with
            xml_root.find(&#39;&lt;element name&gt;&#39;)
        &#34;&#34;&#34;
        import io
        import xml.etree.ElementTree as et
        
        metadata = &#39;&#39;
        read = False
        
        #for slice and view images the metadata is already in xml format
        with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
            #read file line by line to avoid loading too much into memory
            for line in file:
                #start reading at the first line containing an xml tag
                if &#39;&lt;?xml&#39; in line:
                    read = True
                if read:
                    metadata += line
                    if &#39;&lt;/FeiImage&gt;&#39; in line:
                        break #stop at line with end tag
            
        #trim strings down to only xml
        metadata = metadata[metadata.find(&#39;&lt;?xml&#39;):]
        metadata = metadata[:metadata.find(&#39;&lt;/FeiImage&gt;&#39;)+11]
        
        self.metadata = et.fromstring(metadata)
        return self.metadata
        

    def print_metadata(self):
        &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
        
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        util.print_metadata(xml_root)
    
    
    def get_pixelsize(self):
        &#34;&#34;&#34;gets the pixel size from the metadata and calculates the unit&#34;&#34;&#34;
        
        #get the metadata or load it if it is not (yet) available
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        #find the pixelsize (may be two different formats)
        pixelsize_x = float(xml_root.find(&#39;pixelWidth&#39;).text)
        pixelsize_y = float(xml_root.find(&#39;pixelHeight&#39;).text)
        
        #get the unit
        if xml_root.find(&#39;pixelWidth&#39;).attrib[&#39;unit&#39;] != xml_root.find(&#39;pixelHeight&#39;).attrib[&#39;unit&#39;]:
            print(&#39;[WARNING] Unit for x and y not the same, using x unit&#39;)
        unit = xml_root.find(&#39;pixelWidth&#39;).attrib[&#39;unit&#39;]
        if unit == &#39;um&#39;:
            unit = &#39;µm&#39;
        
        #print result
        pixelsize = (pixelsize_x,pixelsize_y)
        print(&#39;Pixel size x: {:.6g}&#39;.format(pixelsize[0]),unit)
        print(&#39;Pixel size y: {:.6g}&#39;.format(pixelsize[1]),unit)
        
        self.pixelsize= pixelsize
        self.unit = unit
        
        return pixelsize,unit


class xl30sfeg:
    &#34;&#34;&#34;
    Set of convenience functions for the xl30sfeg SEM microscope.
    &#34;&#34;&#34;
    def __init__(self,filename):
        &#34;&#34;&#34;initialize class by storing the file name&#34;&#34;&#34;
        
        #raise error if wrong format or file does not exist
        if type(filename) != str:
            raise TypeError(&#39;The argument to the xl30sfeg class must be a string containing the filename.&#39;)
        if not os.path.exists(filename):
            raise FileNotFoundError(&#39;The file &#34;&#39;+filename+&#39;&#34; could not be found.&#39;)
        
        self.filename = filename
    
    def load_image(self):
        &#34;&#34;&#34;load the image and (if present) scalebar&#34;&#34;&#34;
        im = cv2.imread(self.filename,0)
        
        self.shape = np.shape(im)
        self.image = im[:int(self.shape[1]/1.330)]
        
        #check if scalebar is present
        if len(im) &gt; int(self.shape[1]/1.330):
            self.scalebar = im[int(self.shape[1]/1.330):]
        
        return self.image
    
    
    def load_metadata(self):
        &#34;&#34;&#34;
        Load the metadata footer from XL30SFEG SEM files and return xml tree object
        which can be indexed for extraction of useful parameters. Does not require
        loading whole file into memory. Searches for &#39;human&#39; formatted metadata.
        
        @dependencies:
            import io
            import xml.etree.ElementTree as et
        &#34;&#34;&#34;  
        import xml.etree.ElementTree as et
        import io
        
        metadata = &#39;&#39;
        read = False
         
        #construct the metadata from formatted metadata in file
        with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
            for line in file:
                #start reading at first line with [DatabarData], break at last item
                if read:
                    metadata += line
                    if &#39;IonBright3&#39; in line:
                        break
                if &#39;[DatabarData]&#39; in line:
                    read = True
                    metadata += line
        
        metadata = metadata[metadata.find(&#39;[DatabarData]&#39;):]
        metadata = metadata.split(&#34;\n&#34;)
        
        #construct xml object
        xml_root = et.Element(&#39;MetaData&#39;)
        for line in metadata:
            if line != &#39;&#39;:
                if line[0] == &#39;[&#39;:
                    child = et.SubElement(xml_root,line[1:-1].strip())
                else:
                    line = line.split(&#39;=&#39;)
                    subchild = et.SubElement(child,line[0].strip())
                    subchild.text = line[1].strip()
        
        self.metadata = xml_root
        return xml_root
    
    def print_metadata(self):
        &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
        
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        util.print_metadata(xml_root)
    
    def get_pixelsize(self):
        &#34;&#34;&#34;gets the pixelsize from the data&#34;&#34;&#34;
        #try finding metadata, else call load_metadata
        try:
            self.metadata
        except AttributeError:
            self.load_metadata()
        
        
        self.pixelsize = float(self.metadata.find(&#39;DatabarData&#39;).find(&#39;flMagn&#39;).text)
        self.unit = &#39;µm&#39;
        
        return self.pixelsize,self.unit</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scm_electron_microscopes.sem.helios"><code class="flex name class">
<span>class <span class="ident">helios</span></span>
<span>(</span><span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Set of convenience functions for the Helios SEM.</p>
<p>initialize class by loading the file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>name of the file to load. Can but is not required to include .tif
as extension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class helios:
    &#34;&#34;&#34;
    Set of convenience functions for the Helios SEM.
    &#34;&#34;&#34;
    def __init__(self,filename):
        &#34;&#34;&#34;
        initialize class by loading the file

        Parameters
        ----------
        filename : string
            name of the file to load. Can but is not required to include .tif
            as extension.


        Returns
        -------
        None.

        &#34;&#34;&#34;
        
        #raise error if wrong format or file does not exist
        if type(filename) != str:
            raise TypeError(&#39;The argument to the helios class must be a string containing the filename.&#39;)
        if not os.path.exists(filename):
            if os.path.exists(filename + &#39;.tif&#39;):
                filename = filename + &#39;.tif&#39;
            else:
                raise FileNotFoundError(&#39;The file &#34;&#39;+filename+&#39;&#34; could not be found.&#39;)
            
        self.filename = filename
    
    def load_image(self):
        &#34;&#34;&#34;
        load the image and split into image and databar

        Returns
        -------
        numpy.array
            array of pixel values in the image (not including the data bar)

        &#34;&#34;&#34;
        im = cv2.imread(self.filename,0)
        self.shape = np.shape(im)
        self.image = im[:int(self.shape[1]/1.5)]
        if int(self.shape[1]/1.5) &lt; self.shape[0]:
            self.databar = im[int(self.shape[1]/1.5):]
        else:
            self.databar = None
        return self.image
    
    def load_metadata(self):
        &#34;&#34;&#34;
        Load the metadata footer from Helios SEM files and return xml tree
        object which can be indexed for extraction of useful parameters. Does
        not require loading whole file into memory. Attempts first to find xml
        formatted data, if this is not found it looks for &#39;human&#39; formatted
        metadata.

        Returns
        -------
        xml.etree.ElementTree root object
            xml root object of the metadata. Can be printed using it as
            argument to print_metadata, or indexed with
            xml_root.find(&#39;&lt;element name&gt;&#39;).

        &#34;&#34;&#34;
        import io
        import xml.etree.ElementTree as et
        
        metadata = &#39;&#39;
        read = False
        
        #for slice and view images the metadata is already in xml format
        try:
            with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
                #read file line by line to avoid loading too much into memory
                for line in file:
                    #start reading at the first line containing an xml tag
                    if &#39;&lt;?xml&#39; in line:
                        read = True
                    if read:
                        metadata += line
                        if &#39;&lt;/Metadata&gt;&#39; in line:
                            break #stop at line with end tag
            
            #trim strings down to only xml
            metadata = metadata[metadata.find(&#39;&lt;?xml&#39;):]
            metadata = metadata[:metadata.find(&#39;&lt;/Metadata&gt;&#39;)+11]
            
            self.metadata = et.fromstring(metadata)
            return self.metadata
        
        #otherwise construct the metadata from formatted metadata in file
        except:
            with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
                for line in file:
                    #start reading at first line with [User], break at next \x00
                    if read:
                        metadata += line
                        if &#39;\x00&#39; in line:
                            break
                    if &#39;[User]&#39; in line:
                        read = True
                        metadata += line
            
            metadata = metadata[metadata.find(&#39;[User]&#39;):]
            metadata = metadata[:metadata.find(&#39;\x00&#39;)-2]
            metadata = metadata.split(&#39;\n&#39;)
            
            #construct xml object
            xml_root = et.Element(&#39;MetaData&#39;)
            for line in metadata:
                if line != &#39;&#39;:
                    if line[0] == &#39;[&#39;:
                        child = et.SubElement(xml_root,line[1:-1])
                    else:
                        line = line.split(&#39;=&#39;)
                        subchild = et.SubElement(child,line[0])
                        subchild.text = line[1]
            
            self.metadata = xml_root
            return xml_root
    
    def print_metadata(self):
        &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
        
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        util.print_metadata(xml_root)
        
        
    def get_pixelsize(self):
        &#34;&#34;&#34;
        gets the pixel size from the metadata and calculates the unit

        Returns
        -------
        pixelsize : float
            the pixelsize in calibrated (physical) units
        unit : string
            the physical unit of the pixel size

        &#34;&#34;&#34;
        #get the metadata or load it if it is not (yet) available
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        #find the pixelsize (may be two different formats)
        try:
            pixelsize_x = float(xml_root.find(&#39;Scan&#39;).find(&#39;PixelWidth&#39;).text)
            pixelsize_y = float(xml_root.find(&#39;Scan&#39;).find(&#39;PixelHeight&#39;).text)
        except:
            pixelsize_x = float(xml_root.find(&#39;BinaryResult&#39;).find(&#39;PixelSize&#39;).find(&#39;X&#39;).text)
            pixelsize_y = float(xml_root.find(&#39;BinaryResult&#39;).find(&#39;PixelSize&#39;).find(&#39;Y&#39;).text)
        
        #find the right unit and rescale for convenience
        if pixelsize_x &gt;= 0.1:
            unit = &#39;m&#39;
        elif pixelsize_x &lt; 0.1 and pixelsize_x &gt;= 0.1e-3:
            unit = &#39;mm&#39;
            pixelsize_x,pixelsize_y = 1e3*pixelsize_x,1e3*pixelsize_y
        elif pixelsize_x &lt; 0.1e-3 and pixelsize_x &gt;= 0.1e-6:
            unit = &#39;µm&#39;
            pixelsize_x,pixelsize_y = 1e6*pixelsize_x,1e6*pixelsize_y
        else:
            unit = &#39;nm&#39;
            pixelsize_x,pixelsize_y = 1e9*pixelsize_x,1e9*pixelsize_y
        
        pixelsize = (pixelsize_x,pixelsize_y)
        print(&#39;Pixel size x: {:.6g}&#39;.format(pixelsize[0]),unit)
        print(&#39;Pixel size y: {:.6g}&#39;.format(pixelsize[1]),unit)
        
        self.pixelsize= pixelsize
        self.unit = unit
        
        return pixelsize,unit</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scm_electron_microscopes.sem.helios.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>gets the pixel size from the metadata and calculates the unit</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pixelsize</code></strong> :&ensp;<code>float</code></dt>
<dd>the pixelsize in calibrated (physical) units</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>the physical unit of the pixel size</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixelsize(self):
    &#34;&#34;&#34;
    gets the pixel size from the metadata and calculates the unit

    Returns
    -------
    pixelsize : float
        the pixelsize in calibrated (physical) units
    unit : string
        the physical unit of the pixel size

    &#34;&#34;&#34;
    #get the metadata or load it if it is not (yet) available
    try:
        xml_root = self.metadata
    except AttributeError:
        xml_root = self.load_metadata()
    
    #find the pixelsize (may be two different formats)
    try:
        pixelsize_x = float(xml_root.find(&#39;Scan&#39;).find(&#39;PixelWidth&#39;).text)
        pixelsize_y = float(xml_root.find(&#39;Scan&#39;).find(&#39;PixelHeight&#39;).text)
    except:
        pixelsize_x = float(xml_root.find(&#39;BinaryResult&#39;).find(&#39;PixelSize&#39;).find(&#39;X&#39;).text)
        pixelsize_y = float(xml_root.find(&#39;BinaryResult&#39;).find(&#39;PixelSize&#39;).find(&#39;Y&#39;).text)
    
    #find the right unit and rescale for convenience
    if pixelsize_x &gt;= 0.1:
        unit = &#39;m&#39;
    elif pixelsize_x &lt; 0.1 and pixelsize_x &gt;= 0.1e-3:
        unit = &#39;mm&#39;
        pixelsize_x,pixelsize_y = 1e3*pixelsize_x,1e3*pixelsize_y
    elif pixelsize_x &lt; 0.1e-3 and pixelsize_x &gt;= 0.1e-6:
        unit = &#39;µm&#39;
        pixelsize_x,pixelsize_y = 1e6*pixelsize_x,1e6*pixelsize_y
    else:
        unit = &#39;nm&#39;
        pixelsize_x,pixelsize_y = 1e9*pixelsize_x,1e9*pixelsize_y
    
    pixelsize = (pixelsize_x,pixelsize_y)
    print(&#39;Pixel size x: {:.6g}&#39;.format(pixelsize[0]),unit)
    print(&#39;Pixel size y: {:.6g}&#39;.format(pixelsize[1]),unit)
    
    self.pixelsize= pixelsize
    self.unit = unit
    
    return pixelsize,unit</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.helios.load_image"><code class="name flex">
<span>def <span class="ident">load_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>load the image and split into image and databar</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.array</code></dt>
<dd>array of pixel values in the image (not including the data bar)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_image(self):
    &#34;&#34;&#34;
    load the image and split into image and databar

    Returns
    -------
    numpy.array
        array of pixel values in the image (not including the data bar)

    &#34;&#34;&#34;
    im = cv2.imread(self.filename,0)
    self.shape = np.shape(im)
    self.image = im[:int(self.shape[1]/1.5)]
    if int(self.shape[1]/1.5) &lt; self.shape[0]:
        self.databar = im[int(self.shape[1]/1.5):]
    else:
        self.databar = None
    return self.image</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.helios.load_metadata"><code class="name flex">
<span>def <span class="ident">load_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Load the metadata footer from Helios SEM files and return xml tree
object which can be indexed for extraction of useful parameters. Does
not require loading whole file into memory. Attempts first to find xml
formatted data, if this is not found it looks for 'human' formatted
metadata.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xml.etree.ElementTree</code> <code>root</code> <code>object</code></dt>
<dd>xml root object of the metadata. Can be printed using it as
argument to print_metadata, or indexed with
xml_root.find('<element name>').</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_metadata(self):
    &#34;&#34;&#34;
    Load the metadata footer from Helios SEM files and return xml tree
    object which can be indexed for extraction of useful parameters. Does
    not require loading whole file into memory. Attempts first to find xml
    formatted data, if this is not found it looks for &#39;human&#39; formatted
    metadata.

    Returns
    -------
    xml.etree.ElementTree root object
        xml root object of the metadata. Can be printed using it as
        argument to print_metadata, or indexed with
        xml_root.find(&#39;&lt;element name&gt;&#39;).

    &#34;&#34;&#34;
    import io
    import xml.etree.ElementTree as et
    
    metadata = &#39;&#39;
    read = False
    
    #for slice and view images the metadata is already in xml format
    try:
        with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
            #read file line by line to avoid loading too much into memory
            for line in file:
                #start reading at the first line containing an xml tag
                if &#39;&lt;?xml&#39; in line:
                    read = True
                if read:
                    metadata += line
                    if &#39;&lt;/Metadata&gt;&#39; in line:
                        break #stop at line with end tag
        
        #trim strings down to only xml
        metadata = metadata[metadata.find(&#39;&lt;?xml&#39;):]
        metadata = metadata[:metadata.find(&#39;&lt;/Metadata&gt;&#39;)+11]
        
        self.metadata = et.fromstring(metadata)
        return self.metadata
    
    #otherwise construct the metadata from formatted metadata in file
    except:
        with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
            for line in file:
                #start reading at first line with [User], break at next \x00
                if read:
                    metadata += line
                    if &#39;\x00&#39; in line:
                        break
                if &#39;[User]&#39; in line:
                    read = True
                    metadata += line
        
        metadata = metadata[metadata.find(&#39;[User]&#39;):]
        metadata = metadata[:metadata.find(&#39;\x00&#39;)-2]
        metadata = metadata.split(&#39;\n&#39;)
        
        #construct xml object
        xml_root = et.Element(&#39;MetaData&#39;)
        for line in metadata:
            if line != &#39;&#39;:
                if line[0] == &#39;[&#39;:
                    child = et.SubElement(xml_root,line[1:-1])
                else:
                    line = line.split(&#39;=&#39;)
                    subchild = et.SubElement(child,line[0])
                    subchild.text = line[1]
        
        self.metadata = xml_root
        return xml_root</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.helios.print_metadata"><code class="name flex">
<span>def <span class="ident">print_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>print formatted output of metadata</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_metadata(self):
    &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
    
    try:
        xml_root = self.metadata
    except AttributeError:
        xml_root = self.load_metadata()
    
    util.print_metadata(xml_root)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scm_electron_microscopes.sem.phenom"><code class="flex name class">
<span>class <span class="ident">phenom</span></span>
<span>(</span><span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Set of convenience functions for the phenom SEM microscopes.</p>
<p>Initialize the class instance</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class phenom:
    &#34;&#34;&#34;
    Set of convenience functions for the phenom SEM microscopes.
    &#34;&#34;&#34;
    def __init__(self,filename):
        &#34;&#34;&#34;Initialize the class instance&#34;&#34;&#34;
        
        #raise error if wrong format or file does not exist
        if type(filename) != str:
            raise TypeError(&#39;The argument to the helios class must be a string containing the filename.&#39;)
        if not os.path.exists(filename):
            raise FileNotFoundError(&#39;The file &#34;&#39;+filename+&#39;&#34; could not be found.&#39;)
            
        self.filename = filename
    
    def load_image(self):
        &#34;&#34;&#34;load the image and split into image and databar&#34;&#34;&#34;
        im = cv2.imread(self.filename,0)
        self.shape = np.shape(im)
        self.image = im[:int(self.shape[1])]
        self.databar = im[int(self.shape[1]):]
        return self.image
    
    def load_metadata(self):
        &#34;&#34;&#34;
        Load the metadata footer from Helios SEM files and return xml tree
        object which can be indexed for extraction of useful parameters. Does
        not require loading whole file into memory. Attempts first to find xml
        formatted data, if this is not found it looks for &#39;human&#39; formatted
        metadata.
        
        @dependencies:
            import io
            import xml.etree.ElementTree as et
        
        @parameters:
            self.filename:   string
        
        @returns:
            xml root object of the metadata. Can be printed using it as
            argument to print_metadata, or indexed with
            xml_root.find(&#39;&lt;element name&gt;&#39;)
        &#34;&#34;&#34;
        import io
        import xml.etree.ElementTree as et
        
        metadata = &#39;&#39;
        read = False
        
        #for slice and view images the metadata is already in xml format
        with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
            #read file line by line to avoid loading too much into memory
            for line in file:
                #start reading at the first line containing an xml tag
                if &#39;&lt;?xml&#39; in line:
                    read = True
                if read:
                    metadata += line
                    if &#39;&lt;/FeiImage&gt;&#39; in line:
                        break #stop at line with end tag
            
        #trim strings down to only xml
        metadata = metadata[metadata.find(&#39;&lt;?xml&#39;):]
        metadata = metadata[:metadata.find(&#39;&lt;/FeiImage&gt;&#39;)+11]
        
        self.metadata = et.fromstring(metadata)
        return self.metadata
        

    def print_metadata(self):
        &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
        
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        util.print_metadata(xml_root)
    
    
    def get_pixelsize(self):
        &#34;&#34;&#34;gets the pixel size from the metadata and calculates the unit&#34;&#34;&#34;
        
        #get the metadata or load it if it is not (yet) available
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        #find the pixelsize (may be two different formats)
        pixelsize_x = float(xml_root.find(&#39;pixelWidth&#39;).text)
        pixelsize_y = float(xml_root.find(&#39;pixelHeight&#39;).text)
        
        #get the unit
        if xml_root.find(&#39;pixelWidth&#39;).attrib[&#39;unit&#39;] != xml_root.find(&#39;pixelHeight&#39;).attrib[&#39;unit&#39;]:
            print(&#39;[WARNING] Unit for x and y not the same, using x unit&#39;)
        unit = xml_root.find(&#39;pixelWidth&#39;).attrib[&#39;unit&#39;]
        if unit == &#39;um&#39;:
            unit = &#39;µm&#39;
        
        #print result
        pixelsize = (pixelsize_x,pixelsize_y)
        print(&#39;Pixel size x: {:.6g}&#39;.format(pixelsize[0]),unit)
        print(&#39;Pixel size y: {:.6g}&#39;.format(pixelsize[1]),unit)
        
        self.pixelsize= pixelsize
        self.unit = unit
        
        return pixelsize,unit</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scm_electron_microscopes.sem.phenom.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>gets the pixel size from the metadata and calculates the unit</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixelsize(self):
    &#34;&#34;&#34;gets the pixel size from the metadata and calculates the unit&#34;&#34;&#34;
    
    #get the metadata or load it if it is not (yet) available
    try:
        xml_root = self.metadata
    except AttributeError:
        xml_root = self.load_metadata()
    
    #find the pixelsize (may be two different formats)
    pixelsize_x = float(xml_root.find(&#39;pixelWidth&#39;).text)
    pixelsize_y = float(xml_root.find(&#39;pixelHeight&#39;).text)
    
    #get the unit
    if xml_root.find(&#39;pixelWidth&#39;).attrib[&#39;unit&#39;] != xml_root.find(&#39;pixelHeight&#39;).attrib[&#39;unit&#39;]:
        print(&#39;[WARNING] Unit for x and y not the same, using x unit&#39;)
    unit = xml_root.find(&#39;pixelWidth&#39;).attrib[&#39;unit&#39;]
    if unit == &#39;um&#39;:
        unit = &#39;µm&#39;
    
    #print result
    pixelsize = (pixelsize_x,pixelsize_y)
    print(&#39;Pixel size x: {:.6g}&#39;.format(pixelsize[0]),unit)
    print(&#39;Pixel size y: {:.6g}&#39;.format(pixelsize[1]),unit)
    
    self.pixelsize= pixelsize
    self.unit = unit
    
    return pixelsize,unit</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.phenom.load_image"><code class="name flex">
<span>def <span class="ident">load_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>load the image and split into image and databar</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_image(self):
    &#34;&#34;&#34;load the image and split into image and databar&#34;&#34;&#34;
    im = cv2.imread(self.filename,0)
    self.shape = np.shape(im)
    self.image = im[:int(self.shape[1])]
    self.databar = im[int(self.shape[1]):]
    return self.image</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.phenom.load_metadata"><code class="name flex">
<span>def <span class="ident">load_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Load the metadata footer from Helios SEM files and return xml tree
object which can be indexed for extraction of useful parameters. Does
not require loading whole file into memory. Attempts first to find xml
formatted data, if this is not found it looks for 'human' formatted
metadata.</p>
<p>@dependencies:
import io
import xml.etree.ElementTree as et</p>
<p>@parameters:
self.filename:
string</p>
<p>@returns:
xml root object of the metadata. Can be printed using it as
argument to print_metadata, or indexed with
xml_root.find('<element name>')</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_metadata(self):
    &#34;&#34;&#34;
    Load the metadata footer from Helios SEM files and return xml tree
    object which can be indexed for extraction of useful parameters. Does
    not require loading whole file into memory. Attempts first to find xml
    formatted data, if this is not found it looks for &#39;human&#39; formatted
    metadata.
    
    @dependencies:
        import io
        import xml.etree.ElementTree as et
    
    @parameters:
        self.filename:   string
    
    @returns:
        xml root object of the metadata. Can be printed using it as
        argument to print_metadata, or indexed with
        xml_root.find(&#39;&lt;element name&gt;&#39;)
    &#34;&#34;&#34;
    import io
    import xml.etree.ElementTree as et
    
    metadata = &#39;&#39;
    read = False
    
    #for slice and view images the metadata is already in xml format
    with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
        #read file line by line to avoid loading too much into memory
        for line in file:
            #start reading at the first line containing an xml tag
            if &#39;&lt;?xml&#39; in line:
                read = True
            if read:
                metadata += line
                if &#39;&lt;/FeiImage&gt;&#39; in line:
                    break #stop at line with end tag
        
    #trim strings down to only xml
    metadata = metadata[metadata.find(&#39;&lt;?xml&#39;):]
    metadata = metadata[:metadata.find(&#39;&lt;/FeiImage&gt;&#39;)+11]
    
    self.metadata = et.fromstring(metadata)
    return self.metadata</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.phenom.print_metadata"><code class="name flex">
<span>def <span class="ident">print_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>print formatted output of metadata</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_metadata(self):
    &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
    
    try:
        xml_root = self.metadata
    except AttributeError:
        xml_root = self.load_metadata()
    
    util.print_metadata(xml_root)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scm_electron_microscopes.sem.xl30sfeg"><code class="flex name class">
<span>class <span class="ident">xl30sfeg</span></span>
<span>(</span><span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Set of convenience functions for the xl30sfeg SEM microscope.</p>
<p>initialize class by storing the file name</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class xl30sfeg:
    &#34;&#34;&#34;
    Set of convenience functions for the xl30sfeg SEM microscope.
    &#34;&#34;&#34;
    def __init__(self,filename):
        &#34;&#34;&#34;initialize class by storing the file name&#34;&#34;&#34;
        
        #raise error if wrong format or file does not exist
        if type(filename) != str:
            raise TypeError(&#39;The argument to the xl30sfeg class must be a string containing the filename.&#39;)
        if not os.path.exists(filename):
            raise FileNotFoundError(&#39;The file &#34;&#39;+filename+&#39;&#34; could not be found.&#39;)
        
        self.filename = filename
    
    def load_image(self):
        &#34;&#34;&#34;load the image and (if present) scalebar&#34;&#34;&#34;
        im = cv2.imread(self.filename,0)
        
        self.shape = np.shape(im)
        self.image = im[:int(self.shape[1]/1.330)]
        
        #check if scalebar is present
        if len(im) &gt; int(self.shape[1]/1.330):
            self.scalebar = im[int(self.shape[1]/1.330):]
        
        return self.image
    
    
    def load_metadata(self):
        &#34;&#34;&#34;
        Load the metadata footer from XL30SFEG SEM files and return xml tree object
        which can be indexed for extraction of useful parameters. Does not require
        loading whole file into memory. Searches for &#39;human&#39; formatted metadata.
        
        @dependencies:
            import io
            import xml.etree.ElementTree as et
        &#34;&#34;&#34;  
        import xml.etree.ElementTree as et
        import io
        
        metadata = &#39;&#39;
        read = False
         
        #construct the metadata from formatted metadata in file
        with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
            for line in file:
                #start reading at first line with [DatabarData], break at last item
                if read:
                    metadata += line
                    if &#39;IonBright3&#39; in line:
                        break
                if &#39;[DatabarData]&#39; in line:
                    read = True
                    metadata += line
        
        metadata = metadata[metadata.find(&#39;[DatabarData]&#39;):]
        metadata = metadata.split(&#34;\n&#34;)
        
        #construct xml object
        xml_root = et.Element(&#39;MetaData&#39;)
        for line in metadata:
            if line != &#39;&#39;:
                if line[0] == &#39;[&#39;:
                    child = et.SubElement(xml_root,line[1:-1].strip())
                else:
                    line = line.split(&#39;=&#39;)
                    subchild = et.SubElement(child,line[0].strip())
                    subchild.text = line[1].strip()
        
        self.metadata = xml_root
        return xml_root
    
    def print_metadata(self):
        &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
        
        try:
            xml_root = self.metadata
        except AttributeError:
            xml_root = self.load_metadata()
        
        util.print_metadata(xml_root)
    
    def get_pixelsize(self):
        &#34;&#34;&#34;gets the pixelsize from the data&#34;&#34;&#34;
        #try finding metadata, else call load_metadata
        try:
            self.metadata
        except AttributeError:
            self.load_metadata()
        
        
        self.pixelsize = float(self.metadata.find(&#39;DatabarData&#39;).find(&#39;flMagn&#39;).text)
        self.unit = &#39;µm&#39;
        
        return self.pixelsize,self.unit</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scm_electron_microscopes.sem.xl30sfeg.get_pixelsize"><code class="name flex">
<span>def <span class="ident">get_pixelsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>gets the pixelsize from the data</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixelsize(self):
    &#34;&#34;&#34;gets the pixelsize from the data&#34;&#34;&#34;
    #try finding metadata, else call load_metadata
    try:
        self.metadata
    except AttributeError:
        self.load_metadata()
    
    
    self.pixelsize = float(self.metadata.find(&#39;DatabarData&#39;).find(&#39;flMagn&#39;).text)
    self.unit = &#39;µm&#39;
    
    return self.pixelsize,self.unit</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.xl30sfeg.load_image"><code class="name flex">
<span>def <span class="ident">load_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>load the image and (if present) scalebar</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_image(self):
    &#34;&#34;&#34;load the image and (if present) scalebar&#34;&#34;&#34;
    im = cv2.imread(self.filename,0)
    
    self.shape = np.shape(im)
    self.image = im[:int(self.shape[1]/1.330)]
    
    #check if scalebar is present
    if len(im) &gt; int(self.shape[1]/1.330):
        self.scalebar = im[int(self.shape[1]/1.330):]
    
    return self.image</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.xl30sfeg.load_metadata"><code class="name flex">
<span>def <span class="ident">load_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Load the metadata footer from XL30SFEG SEM files and return xml tree object
which can be indexed for extraction of useful parameters. Does not require
loading whole file into memory. Searches for 'human' formatted metadata.</p>
<p>@dependencies:
import io
import xml.etree.ElementTree as et</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_metadata(self):
    &#34;&#34;&#34;
    Load the metadata footer from XL30SFEG SEM files and return xml tree object
    which can be indexed for extraction of useful parameters. Does not require
    loading whole file into memory. Searches for &#39;human&#39; formatted metadata.
    
    @dependencies:
        import io
        import xml.etree.ElementTree as et
    &#34;&#34;&#34;  
    import xml.etree.ElementTree as et
    import io
    
    metadata = &#39;&#39;
    read = False
     
    #construct the metadata from formatted metadata in file
    with io.open(self.filename, &#39;r&#39;, errors=&#39;ignore&#39;, encoding=&#39;utf8&#39;) as file:
        for line in file:
            #start reading at first line with [DatabarData], break at last item
            if read:
                metadata += line
                if &#39;IonBright3&#39; in line:
                    break
            if &#39;[DatabarData]&#39; in line:
                read = True
                metadata += line
    
    metadata = metadata[metadata.find(&#39;[DatabarData]&#39;):]
    metadata = metadata.split(&#34;\n&#34;)
    
    #construct xml object
    xml_root = et.Element(&#39;MetaData&#39;)
    for line in metadata:
        if line != &#39;&#39;:
            if line[0] == &#39;[&#39;:
                child = et.SubElement(xml_root,line[1:-1].strip())
            else:
                line = line.split(&#39;=&#39;)
                subchild = et.SubElement(child,line[0].strip())
                subchild.text = line[1].strip()
    
    self.metadata = xml_root
    return xml_root</code></pre>
</details>
</dd>
<dt id="scm_electron_microscopes.sem.xl30sfeg.print_metadata"><code class="name flex">
<span>def <span class="ident">print_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>print formatted output of metadata</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_metadata(self):
    &#34;&#34;&#34;print formatted output of metadata&#34;&#34;&#34;
    
    try:
        xml_root = self.metadata
    except AttributeError:
        xml_root = self.load_metadata()
    
    util.print_metadata(xml_root)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scm_electron_microscopes" href="index.html">scm_electron_microscopes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scm_electron_microscopes.sem.helios" href="#scm_electron_microscopes.sem.helios">helios</a></code></h4>
<ul class="">
<li><code><a title="scm_electron_microscopes.sem.helios.get_pixelsize" href="#scm_electron_microscopes.sem.helios.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.helios.load_image" href="#scm_electron_microscopes.sem.helios.load_image">load_image</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.helios.load_metadata" href="#scm_electron_microscopes.sem.helios.load_metadata">load_metadata</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.helios.print_metadata" href="#scm_electron_microscopes.sem.helios.print_metadata">print_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_electron_microscopes.sem.phenom" href="#scm_electron_microscopes.sem.phenom">phenom</a></code></h4>
<ul class="">
<li><code><a title="scm_electron_microscopes.sem.phenom.get_pixelsize" href="#scm_electron_microscopes.sem.phenom.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.phenom.load_image" href="#scm_electron_microscopes.sem.phenom.load_image">load_image</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.phenom.load_metadata" href="#scm_electron_microscopes.sem.phenom.load_metadata">load_metadata</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.phenom.print_metadata" href="#scm_electron_microscopes.sem.phenom.print_metadata">print_metadata</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scm_electron_microscopes.sem.xl30sfeg" href="#scm_electron_microscopes.sem.xl30sfeg">xl30sfeg</a></code></h4>
<ul class="">
<li><code><a title="scm_electron_microscopes.sem.xl30sfeg.get_pixelsize" href="#scm_electron_microscopes.sem.xl30sfeg.get_pixelsize">get_pixelsize</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.xl30sfeg.load_image" href="#scm_electron_microscopes.sem.xl30sfeg.load_image">load_image</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.xl30sfeg.load_metadata" href="#scm_electron_microscopes.sem.xl30sfeg.load_metadata">load_metadata</a></code></li>
<li><code><a title="scm_electron_microscopes.sem.xl30sfeg.print_metadata" href="#scm_electron_microscopes.sem.xl30sfeg.print_metadata">print_metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>